<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sublime插件整理]]></title>
    <url>%2F2017%2F12%2F16%2F%E5%B7%A5%E5%85%B7%2Fsublime%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[sasslessbabelemmet emmet jsx// add to Preferences &gt; Key Bindings - User// see http://stackoverflow.com/a/26619524 for context123456789101112131415161718192021&#123; &quot;keys&quot;: [&quot;tab&quot;], &quot;command&quot;: &quot;expand_abbreviation_by_tab&quot;, &quot;context&quot;: [ &#123; &quot;operand&quot;: &quot;source.js&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;match_all&quot;: true, &quot;key&quot;: &quot;selector&quot; &#125;, &#123; &quot;key&quot;: &quot;selection_empty&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true, &quot;match_all&quot;: true &#125; ]&#125;,&#123; &quot;keys&quot;: [&quot;tab&quot;], &quot;command&quot;: &quot;next_field&quot;, &quot;context&quot;: [ &#123; &quot;key&quot;: &quot;has_next_field&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true &#125; ]&#125; sublime 显示空格和制表符Preferences-&gt;Settings-User“draw_white_space”: “all” 符号高亮 Bracket​Highlighter 扩展右键菜单 SideBarEnhancements 语法检查 Sublime​Linter SublimeLinter-contrib-eslint ESLint-Formatter js提示 JavaScript Completions 自动提示文件名 AutoFileName 文件图标 A File Icon markdown 预览 Markdown Extended 不同的编辑器之间保持一致的编码风格 EditorConfig]]></content>
      <tags>
        <tag>sbulime</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment ContributingContribution is welcome, feel free to open an issue and fork. Waiting for your pull request.]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime安装packageControl]]></title>
    <url>%2F2017%2F09%2F09%2Fsublime%E5%AE%89%E8%A3%85packageControl%2F</url>
    <content type="text"><![CDATA[原来Subl3安装Package Control很麻烦，现在简单的方法来了 一、简单的安装方法 使用Ctrl+`快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码：1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 如果顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了。 顺便贴下Sublime Text2 的代码：1import urllib2,os; pf=&apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &apos;wb&apos; ).write( urllib2.urlopen( &apos;http://sublime.wbond.net/&apos; +pf.replace( &apos; &apos;,&apos;%20&apos; )).read()); print( &apos;Please restart Sublime Text to finish installation&apos;) 二、手动安装 可能由于各种原因，无法使用代码安装，那可以通过以下步骤手动安装Package Control： 1.点击Preferences &gt; Browse Packages菜单 2.进入打开的目录的上层目录，然后再进入Installed Packages/目录 3.下载Package Control.sublime-package并复制到Installed Packages/目录 4.重启Sublime Text。]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT 精于心，简于形]]></title>
    <url>%2F2017%2F09%2F09%2Fhexo%2Fhexo-themes-Next%2F</url>
    <content type="text"><![CDATA[NexT 精于心，简于形 在线预览 Preview | NexT 使用文档 | English Documentation 浏览器支持 Browser support 贡献 Contributing接受各种形式的贡献，包括不限于提交问题与需求，修复代码。等待您的Pull Request。 Any types of contribution are welcome. Thanks. 开发 DevelopmentNexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。 NexT is built for easily use with elegant appearance. First things first, always keep things simple. 开发历史 Changelog]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp压缩脚本]]></title>
    <url>%2F2017%2F09%2F09%2Fjs%2Fgulp%E5%8E%8B%E7%BC%A9%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[自己手动写了一个压缩脚本，主要实现了对比压缩，没有改变的文件不会压缩大大缩小了压缩时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354var gulp = require("gulp"), del = require('del'), rev = require("gulp-rev"), revReplace = require("gulp-rev-replace"), uglify = require("gulp-uglify"), minifyCss = require('gulp-minify-css'), concat = require('gulp-concat'), replace = require('gulp-replace-task'), htmlmin = require('gulp-htmlmin'), runSequence = require('run-sequence'), imagemin = require('gulp-imagemin'), pngquant = require('imagemin-pngquant'), gulpif = require('gulp-if'), fs = require('fs');var path = ".build"var opt = &#123; backpath: path + "/back", zippath: path + "/zip", revpath: path + "/rev"&#125;opt.ziprevpath = opt.zippath + "/rev"///////////////////////////////////压缩////////////////////////////////////////////////////////gulp.task("delrev", function(cb) &#123; del('rev', &#123; force: true &#125;).then(function() &#123; cb(); &#125;);&#125;)gulp.task("ziporiginal", function() &#123; return gulp.src([opt.zippath + "/**", opt.zippath + "/*.*"]) .pipe(gulp.dest(""))&#125;)gulp.task("copyrev", function() &#123; return gulp.src(opt.revpath + "/rev.json") .pipe(gulp.dest(opt.ziprevpath))&#125;)gulp.task("uglifyall", function(cb) &#123; //如果有旧版本文件，就开始对比 if (zipbackdir_rev_status) &#123; console.log("开始对比"); //得出对比后有的差异 var obj = revCompared(opt.revpath + "/rev.json", opt.ziprevpath + "/rev.json") if (!obj.arr.length) &#123; console.log("没有文件改变") &#125; if (obj.del.arr.length) &#123; for (var i = 0; i &lt; obj.del.arr.length; i++) &#123; //先检查一下，zipback里面是否还有这个文件，如果没有则跳过 if (!fs.existsSync(opt.zippath + "/" + obj.del.arr[i])) &#123; continue; &#125; //走到这里说明有删除文件，开始走删除文件方法 deldir(obj.del.arr[i]) function deldir(url) &#123; //解析文件路径，从第一级开始比较，如果，第一级或是第二级。。。新文件里没有了。而老文件里有，说明要删除 urlarr = url.split("/") var str = urlarr[0]; for (var i = 0; i &lt; urlarr.length; i++) &#123; //得出文件夹转台 var dir = fs.existsSync(str) //得出备份文件夹状态 var zip_dir = fs.existsSync(opt.zippath + "/" + str) //如果新文件夹里没有。旧文件里有，说明是删除，则执行删除文件 if (!dir &amp;&amp; zip_dir) &#123; console.log("del：" + str) del.sync(opt.zippath + "/" + str, &#123; force: true &#125;) &#125; //走到这一步说明新文件夹里有，则进入下一级目录 str += "/" + urlarr[i + 1] &#125; &#125; //如果删除文件后是空文件夹，应该把备份里的空文件夹也删除 &#125; &#125; &#125; else &#123; //没有旧版本文件，就只读取新文件，然后执行 console.log("全量压缩") var obj = revCompared(opt.revpath + "/rev.json") &#125; console.log(obj.arr) return gulp.src(obj.arr, &#123; base: "./" &#125;) .pipe(gulpif(["*.js", "**/*.js", "!js/config**"], uglify())) .pipe(gulpif("*.css", minifyCss())) .pipe(gulpif(["*.html"], htmlmin(&#123; collapseWhitespace: true &#125;))) .pipe(gulpif(["*.tpl"],htmlmin(&#123;collapseWhitespace: true&#125;))) .pipe(gulpif("*.jpg", imagemin(&#123; progressive: true, svgoPlugins: [&#123; removeViewBox: false &#125;], use: [pngquant()] &#125;))) .pipe(gulp.dest(opt.zippath));&#125;)//以上开始压缩js//以下都是为了得出文件版本号gulp.task("main_production", function() &#123; return gulp.src(['js/main_production.js',opt.revpath+'/rev.json']) .pipe(concat("main.js")) //.pipe(uglify()) .pipe(gulp.dest(opt.zippath+"/js")) &#125;)gulp.task("test", function() &#123; //return gulp.src(["js/templates/base/wrap.tpl"]) //return gulp.src(["js/templates/base/header.tpl"]) return gulp.src(["js/templates/base/menu.tpl"]) .pipe(uglify()) .pipe(gulp.dest(opt.zippath + "htmlmin")) &#125;) //以上开始压缩js //以下都是为了得出文件版本号 // gulp.task("concatconfig", function() &#123; // return gulp.src(["js/config.production.js", opt.revpath + "/rev.json"]) // .pipe(concat("config.js")) // .pipe(gulp.dest(opt.zippath + "/js")) // &#125;)gulp.task("rev", function() &#123; return gulp.src(excludefile.concat('!js/main_production.js','!js/main.js')) .pipe(rev()) .pipe(rev.manifest("rev.json")) .pipe(replace(&#123; //替换字符串 patterns: [&#123; match: /['|"](.&#123;1,&#125;)['|"].&#123;1,&#125;['|"].*-&#123;1,&#125;?(.[^.]*).&#123;1,&#125;['|"]/g, replacement: '"$1":"$1?v=$2"' &#125;] &#125;)) .pipe(gulp.dest(opt.revpath)) &#125;) //图片，字体，样式都完成之后，开始替换js，再生成js文件版本号（注意这里只是生成js文件里js文件版本号，）gulp.task("js", function() &#123; var rev_static = gulp.src(".rev/rev-static.json"); var rev_style = gulp.src(".rev/rev-style.json"); var rev_tpl = gulp.src(".rev/rev-tpl.json"); return gulp.src(["*/**/*.*js", "*/*.*js"]) .pipe(revReplace(&#123; manifest: rev_static &#125;)) .pipe(revReplace(&#123; manifest: rev_style &#125;)) .pipe(revReplace(&#123; manifest: rev_tpl &#125;)) .pipe(gulp.dest("")) .pipe(rev()) .pipe(rev.manifest("rev-js.json")) .pipe(replace(&#123; //替换字符串 patterns: [&#123; match: /['|"](.&#123;1,&#125;)['|"].&#123;1,&#125;['|"].*-&#123;1,&#125;?(.[^.]*).&#123;1,&#125;['|"]/g, replacement: '"$1":"$1?v=$2"' &#125;] &#125;)) .pipe(gulp.dest(opt.revpath)) &#125;) //图片，字体，样式都完成之后，开始替换js，再生成js文件版本号（注意这里只是生成js文件里js文件版本号，）gulp.task("tpl", function() &#123; var rev_static = gulp.src(".rev/rev-static.json"); var rev_style = gulp.src(".rev/rev-style.json"); return gulp.src(["*/**/*.*tpl", "*/*.*tpl"]) .pipe(revReplace(&#123; manifest: rev_static &#125;)) .pipe(revReplace(&#123; manifest: rev_style &#125;)) .pipe(gulp.dest("")) .pipe(rev()) .pipe(rev.manifest("rev-tpl.json")) .pipe(replace(&#123; //替换字符串 patterns: [&#123; match: /['|"](.&#123;1,&#125;)['|"].&#123;1,&#125;['|"].*-&#123;1,&#125;?(.[^.]*).&#123;1,&#125;['|"]/g, replacement: '"$1":"$1?v=$2"' &#125;] &#125;)) .pipe(gulp.dest(opt.revpath)) &#125;) //替换css里在的图片路径，并生成CSS版本号文件rev-style.jsongulp.task("css", function() &#123; var rev_static = gulp.src(opt.revpath + "/rev-static.json"); return gulp.src(['*/**/*.*css', '*/*.*css']) .pipe(revReplace(&#123; manifest: rev_static &#125;)) .pipe(gulp.dest("")) .pipe(rev()) .pipe(rev.manifest("rev-style.json")) .pipe(replace(&#123; //替换字符串 patterns: [&#123; match: /['|"](.&#123;1,&#125;)['|"].&#123;1,&#125;['|"].*-&#123;1,&#125;?(.[^.]*).&#123;1,&#125;['|"]/g, replacement: '"$1":"$1?v=$2"' &#125;] &#125;)) .pipe(gulp.dest(opt.revpath)) &#125;) //生成所有静态资源版本号文件gulp.task("static", function() &#123; return gulp.src(["*/**/*.!(*css|*js|*tpl)", "*/*.!(*css|*js|*tpl)"]) .pipe(rev()) .pipe(rev.manifest("rev-static.json")) .pipe(replace(&#123; //替换字符串 patterns: [&#123; match: /['|"](.&#123;1,&#125;)['|"].&#123;1,&#125;['|"].*-&#123;1,&#125;?(.[^.]*).&#123;1,&#125;['|"]/g, replacement: '"$1":"$1?v=$2"' &#125;] &#125;)) .pipe(gulp.dest(opt.revpath)) &#125;) //压缩之前先把所有的文件备份一遍gulp.task("copy", function() &#123; return gulp.src(excludefile) .pipe(gulp.dest(opt.backpath))&#125;)gulp.task('zip', function(cb) &#123; runSequence('copy', 'static', 'css', 'tpl', 'js', 'rev','main_production', 'uglifyall', "copyrev", 'ziporiginal','delrev', cb);&#125;);function revCompared(newfile, oldfile) &#123; //文件对比。对比两个json版本文件。 //如果新文件里有，旧文件里没有，说明是新加 //如果旧文件里有，新文件里没有，说明是删除 //如果新文件里有，旧文件里也有，但不一样，说明文件内容有改变 //以上三种情况都会被添加到返回的对象中 //读取新版本文件 var rev = fs.readFileSync(newfile); //新文件转化为json var json_rev = JSON.parse(rev); //返回的对象,存放所有对比结果 var obj = &#123;&#125;; //存放新加、改动文件的对象 obj.arr = [] obj.json = &#123;&#125; //存放新增文件的对象 obj.add = &#123;&#125; obj.add.arr = [] obj.add.json = &#123;&#125; //存放删除文件的对象 obj.del = &#123;&#125; obj.del.arr = [] obj.del.json = &#123;&#125; //只存放改动文件的对象 obj.change = &#123;&#125; obj.change.arr = [] obj.change.json = &#123;&#125; //看是否有老版本文件 if (oldfile) &#123; //读取老版本文件 var ziprev = fs.readFileSync(oldfile) //老版本文件转为json var json_ziprev = JSON.parse(ziprev) //先循环新版本文件，跟老版本文件进行文件版本对比 for (a in json_rev) &#123; //如果老文件里面没有这个文件，说明是新增文件 if (!json_ziprev[a]) &#123; obj.add.arr.push(a) obj.add.json[a] = json_rev[a] obj.arr.push(a) obj.json[a] = json_rev[a] //如果老文件有，但版本号不一样，说明内容有变动 &#125; else if (json_rev[a] != json_ziprev[a]) &#123; obj.change.arr.push(a); obj.change.json[a] = json_rev[a]; obj.arr.push(a); obj.json[a] = json_rev[a]; &#125; &#125;; (function() &#123; //循环旧版本文件 for (a in json_ziprev) &#123; //如果旧版本文件里有，新版本文件里没有则是删除 if (!json_rev[a]) &#123; //将改动的文件放入删除对象中 obj.del.arr.push(a) obj.del.json[a] = json_ziprev[a] &#125; &#125; &#125;)(); return obj &#125; else &#123; //如果没有老版本文件，循环新版本文件。放入到对象中 for (a in json_rev) &#123; obj.arr.push(a) obj.json[a] = json_rev[a] &#125; return obj &#125;&#125;/////////////////////////////解压/////////////////////////////////////////////////////////要还原之前，首先把原来的代码进行备份gulp.task("zipback", function() &#123; return gulp.src(excludefile.concat("!rev/**", "!rev*")) .pipe(gulp.dest(opt.zippath)) &#125;) //压缩代码备份完之后，开始还原代码,这不是还原，这是覆盖，应该删除之前的所有文件夹，再还原。。。待改gulp.task("recovery", function() &#123; return gulp.src(opt.backpath + "/**") .pipe(gulp.dest(""))&#125;)gulp.task("delback", function(cb) &#123; del([opt.backpath], &#123; force: true &#125;).then(function() &#123; cb(); &#125;)&#125;)gulp.task('unzip', function(cb) &#123; runSequence('zipback', 'recovery', 'delback', cb);&#125;);////////////////////////////////////////////////////////////////////////var gulpbackdir_status = fs.existsSync(opt.backpath)var zipbackdir_rev_status = fs.existsSync(opt.ziprevpath + "/rev.json");//跑脚本时忽略文件var excludefile = ["**",'!node_modules/**','!package.json', "!gulpfile.js", "!" + path + "/**", "!" + path + "**"]var build;if (gulpbackdir_status) &#123; build = ["unzip"]&#125; else &#123; build = ["zip"]&#125;//入口gulp.task("default", build, function(cb) &#123; cb()&#125;);]]></content>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo各种设置]]></title>
    <url>%2F2017%2F09%2F09%2Fhexo%2Fhexo%E5%90%84%E7%A7%8D%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主题设置hexo-themes-next官网教程hexo里使用图床]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js手动触发addEventListener]]></title>
    <url>%2F2017%2F09%2F09%2Fjs%2F%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91addeventListener%2F</url>
    <content type="text"><![CDATA[js 中 document.createEvent的用法-转载js 中 document.createEvent的用法 评论 如果用户直接查看文章列表，那么所有的评论以及评论框都是不显示的，但是如果用户通过别的页面比如首页的个人动态直接定位到这篇日志，那么评论就应该全部显示。而列表页和查看单个条目的页面是同一个页面，这就要求我判断一下用户是否定位到该篇日志，如果是，就通过JS来触发 A 标签的点击事件。 一开始我尝试了一些方法，想当然地以为 A 标签和按钮一样是有 onclick() 事件的，结果发现没有，后来从网上搜了一些资料之后，成功解决了这个问题^_^ 。解决办法是针对 IE 和 FF编写不同的逻辑，部分代码如下： var comment = document.getElementsByTagName('a')[0]; if (document.all) { // For IE comment.click(); } else if (document.createEvent) { //FOR DOM2 var ev = document.createEvent('HTMLEvents'); ev.initEvent('click', false, true); comment.dispatchEvent(ev); } 语法： createEvent(eventType) 参数 描述 eventType 想获取的 Event 对象的事件模块名。 关于有效的事件类型列表，请参阅”说明”部分。 返回值 返回新创建的 Event 对象，具有指定的类型。 抛出 如果实现支持需要的事件类型，该方法将抛出代码为 NOT_SUPPORTED_ERR 的 DOMException 异常。 说明 该方法将创建一种新的事件类型，该类型由参数 eventType 指定。注意，该参数的值不是要创建的事件接口的名称，而是定义那个接口的 DOM 模块的名称。 下表列出了 eventType 的合法值和每个值创建的事件接口： 参数 事件接口 初始化方法 HTMLEvents HTMLEvent iniEvent() MouseEvents MouseEvent iniMouseEvent() UIEvents UIEvent iniUIEvent() 用该方法创建了 Event 对象以后，必须用上表中所示的初始化方法初始化对象。关于初始化方法的详细信息，请参阅 Event 对象参考。 该方法实际上不是由 Document 接口定义的，而是由 DocumentEvent 接口定义的。如果一个实现支持 Event 模块，那么 Document 对象就会实现 DocumentEvent 接口并支持该方法。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window Tidy：窗口定位魔术师]]></title>
    <url>%2F2017%2F09%2F09%2F%E5%B7%A5%E5%85%B7%2FwindowTidy%2F</url>
    <content type="text"><![CDATA[由于本人一向“喜新厌旧”的性格，导致前一阵子超爱的窗口工具Cinch也被我弃用了，现在又换成了Window Tidy，选择WT的原因是这款软件自带灵活的Grid模式，这样能随意定义窗口大小，再加上不限数量的Layout（布局模式），让多个窗口各据其位，互不干扰，帮我解决了许多排窗口的工作。以下是演示视频]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费VPN推荐]]></title>
    <url>%2F2017%2F09%2F09%2F%E5%B7%A5%E5%85%B7%2F%E7%BF%BB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[免费VPN下载地址：蓝灯 google赞助的，支持各种移动端，不用任何账号设置。直接上网（推荐） 下载地址：ishadowsocks这也是一个免费的，不过要设置账号密码，六个小时一换，速度也没有蓝灯快，优点是官网没有被墙，打开无障碍，如果蓝灯下载不下来，可以先用这个过渡]]></content>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
</search>
